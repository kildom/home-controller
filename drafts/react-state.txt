in react I can update state from e.g. some event generated by some component that I added. How to handle situations when some event was executed outside my component tree, e.g. library unaware or react. How to change a state since function updating state is outside of scope of that external library. Show me some example where external library calls global function userConnected and in it I want to change state by setting property connected to true.

Great question ‚Äî this is a very common integration problem when mixing React with non-React / legacy / third-party JS that fires events ‚Äúfrom the outside‚Äù.

You correctly identified the core issue:

setState (or setConnected) lives inside React component scope, but the external library calls a global function like userConnected() that knows nothing about React.

You should never try to directly reach into React from that global function.
Instead, you create a bridge between the outside world and React.

The clean, idiomatic way in React is:

External world ‚Üí event/emitter/store ‚Üí React subscribes ‚Üí state updates

Not:

External world ‚Üí call React state directly

‚úÖ The Pattern: External Event ‚Üí Event Bus ‚Üí React Subscription

We‚Äôll simulate your case:

External library calls:

window.userConnected()


You want React state:

connected === true

Step 1 ‚Äî Create a tiny event bus (outside React)

This file is plain JS, no React.

connectionEvents.js
const listeners = new Set();

export function subscribe(listener) {
  listeners.add(listener);
  return () => listeners.delete(listener);
}

export function emitUserConnected() {
  listeners.forEach((l) => l());
}


This is a minimal pub/sub system.

Step 2 ‚Äî Make the global function call the event bus

This is what the external library will call.

globalBridge.js
import { emitUserConnected } from './connectionEvents';

window.userConnected = function () {
  emitUserConnected();
};


Now the external world triggers your event system, not React.

Step 3 ‚Äî React subscribes to that event
App.jsx
import { useEffect, useState } from 'react';
import { subscribe } from './connectionEvents';

export default function App() {
  const [connected, setConnected] = useState(false);

  useEffect(() => {
    const unsubscribe = subscribe(() => {
      setConnected(true);
    });

    return unsubscribe;
  }, []);

  return (
    <div>
      <h1>Status: {connected ? 'Connected ‚úÖ' : 'Disconnected ‚ùå'}</h1>
    </div>
  );
}

Step 4 ‚Äî What the external library does

Somewhere completely outside React:

// External lib, legacy script, websocket, etc
setTimeout(() => {
  window.userConnected(); // React updates!
}, 3000);

Why this is the correct solution

You avoided all the bad patterns:

‚ùå Storing setConnected on window
‚ùå Passing React functions into non-React code
‚ùå Coupling React lifecycle to external scripts

Instead you built:

A message channel React can listen to

This is exactly how Redux, Zustand, RxJS, etc. integrate with non-React code.

üöÄ Even Cleaner: Using useSyncExternalStore (React 18+ idiomatic way)

React actually has a hook made exactly for this situation.

connectionStore.js
let connected = false;
const listeners = new Set();

export function userConnected() {
  connected = true;
  listeners.forEach((l) => l());
}

export function subscribe(listener) {
  listeners.add(listener);
  return () => listeners.delete(listener);
}

export function getSnapshot() {
  return connected;
}


Expose to global:

import { userConnected } from './connectionStore';
window.userConnected = userConnected;

React side:
import { useSyncExternalStore } from 'react';
import { subscribe, getSnapshot } from './connectionStore';

export default function App() {
  const connected = useSyncExternalStore(subscribe, getSnapshot);

  return (
    <div>
      <h1>Status: {connected ? 'Connected ‚úÖ' : 'Disconnected ‚ùå'}</h1>
    </div>
  );
}


This is the most React-correct solution possible.

Mental Model (important)

You never want:

external ‚Üí React


You want:

external ‚Üí store/event ‚Üí React subscribes


React pulls state, it is never pushed into.

That‚Äôs the key architectural idea.

Real-world examples where this is required

This exact pattern is used when integrating with:

WebSocket clients

Firebase SDK

Stripe SDK

Maps SDKs

Legacy jQuery apps

Browser extensions

Analytics SDKs

Electron / Native bridges

All of them fire events outside React.

Summary

When something outside React wants to change React state:

Create a small external store/event system

Let the external library talk to that

Let React subscribe to it

Never pass React state setters outside.

If I have an async function that runs for all the time and as result of its execution the state should change. How to do that? For example the function body is following (with comments where react state should be changed):

for (let i = 0; i < n; i++) {
    // set state: stage = `Receiving item {i} of {n}`
    data = await receive(n);
    // set state: stage = `Processing item {i} of {n}`
    let processed = await process(data);
    // set state: stage = `Sending item {i} of {n}`
    await send(n, processed);
}
// set state: stage = `Done`

This is the same class of problem as before, but trickier:

A long-running async workflow lives outside React, but React UI must reflect its progress.

If you try to do this:

async function job(setStage) { ... }


you are already in the wrong direction ‚Äî you are leaking React into your business logic.

That becomes untestable, non-reusable, and tightly coupled.

The correct mental model is again:

Long async process ‚Üí emits progress ‚Üí React subscribes ‚Üí UI updates

You do not ‚Äúset React state from the loop‚Äù.

You publish progress from the loop.

‚úÖ Proper Architecture
async worker  ‚îÄ‚îÄ‚ñ∫ progress store ‚îÄ‚îÄ‚ñ∫ React subscribes


React is only a viewer of progress.

Step 1 ‚Äî Create a progress store (plain JS, no React)
progressStore.js
let stage = 'Idle';
const listeners = new Set();

export function setStage(newStage) {
  stage = newStage;
  listeners.forEach((l) => l());
}

export function subscribe(listener) {
  listeners.add(listener);
  return () => listeners.delete(listener);
}

export function getSnapshot() {
  return stage;
}

Step 2 ‚Äî Your long async function uses the store

Notice: no React here

worker.js
import { setStage } from './progressStore';

export async function runJob(n) {
  for (let i = 0; i < n; i++) {
    setStage(`Receiving item ${i + 1} of ${n}`);
    const data = await receive(n);

    setStage(`Processing item ${i + 1} of ${n}`);
    const processed = await process(data);

    setStage(`Sending item ${i + 1} of ${n}`);
    await send(n, processed);
  }

  setStage('Done');
}


This function can now be used:

in React

in Node

in tests

in CLI

in workers

No React coupling.

Step 3 ‚Äî React subscribes using useSyncExternalStore
App.jsx
import { useSyncExternalStore } from 'react';
import { subscribe, getSnapshot } from './progressStore';
import { runJob } from './worker';

export default function App() {
  const stage = useSyncExternalStore(subscribe, getSnapshot);

  return (
    <div>
      <h1>{stage}</h1>
      <button onClick={() => runJob(5)}>Start</button>
    </div>
  );
}

Why this is much better than passing setStage

If you instead did this:

runJob(n, setStage)


you create these problems:

Worker can only run inside React

Impossible to unit test cleanly

Harder to reuse

Violates separation of concerns

Harder to reason about concurrency

This pattern (store + subscription) is exactly what Redux, Zustand, React Query, Firebase, WebSockets, etc. do internally.

üß† Even More Elegant: Use an Async Generator (best pattern for progress)

This is the cleanest possible design for long processes.

worker.js
export async function* runJob(n) {
  for (let i = 0; i < n; i++) {
    yield `Receiving item ${i + 1} of ${n}`;
    const data = await receive(n);

    yield `Processing item ${i + 1} of ${n}`;
    const processed = await process(data);

    yield `Sending item ${i + 1} of ${n}`;
    await send(n, processed);
  }

  yield 'Done';
}


This function now emits progress naturally.

No store. No React. Pure logic.

React consumes it:
import { useState } from 'react';
import { runJob } from './worker';

export default function App() {
  const [stage, setStage] = useState('Idle');

  async function start() {
    for await (const s of runJob(5)) {
      setStage(s);
    }
  }

  return (
    <div>
      <h1>{stage}</h1>
      <button onClick={start}>Start</button>
    </div>
  );
}


This is incredibly powerful because:

Worker is pure

React controls lifecycle

Easy cancellation

Easy testing

No global state

No coupling

Which approach should you use?
Situation	Best pattern
External lib triggers progress	Store + useSyncExternalStore
Long internal async job	Async generator (best)
You need global observable progress	Store
You want most elegant architecture	Async generator
The key insight

You never want:

async loop ‚Üí setReactState()


You want:

async loop ‚Üí emit progress
React ‚Üí observe progress


That‚Äôs the React mental model.

is there any way to avoid the same pattern as progressStore.js. Is there any ready-to-use helper to simplify that code?

Yes ‚Äî and this is an excellent instinct.

What you wrote in progressStore.js is not your app logic.
It‚Äôs a tiny state manager.

So the real question is:

‚ÄúDo I really have to reinvent a mini Redux every time I want external / async / non-React code to talk to React?‚Äù

No. Absolutely not.

This exact problem is why lightweight stores like Zustand exist.

Zustand is literally designed for:

‚Äústate that must be updated from outside React‚Äù

No providers. No boilerplate. No reducers. No context. No ceremony.

‚úÖ The Ready-to-Use Helper: Zustand

Install:

npm install zustand

Step 1 ‚Äî Create a store (replaces progressStore.js)
progressStore.js
import { create } from 'zustand';

export const useProgressStore = create((set) => ({
  stage: 'Idle',
  setStage: (stage) => set({ stage }),
}));


That‚Äôs it. No subscribe. No listeners. No getSnapshot.

Zustand already implements the exact pattern React expects internally.

Step 2 ‚Äî Your async worker (outside React!)
import { useProgressStore } from './progressStore';

export async function runJob(n) {
  const setStage = useProgressStore.getState().setStage;

  for (let i = 0; i < n; i++) {
    setStage(`Receiving item ${i + 1} of ${n}`);
    const data = await receive(n);

    setStage(`Processing item ${i + 1} of ${n}`);
    const processed = await process(data);

    setStage(`Sending item ${i + 1} of ${n}`);
    await send(n, processed);
  }

  setStage('Done');
}


üî• Notice the magic line:

useProgressStore.getState()


This is the official, supported way to update state from outside React.

This is exactly the problem Zustand was built to solve.

Step 3 ‚Äî React just uses it like normal state
import { useProgressStore } from './progressStore';
import { runJob } from './worker';

export default function App() {
  const stage = useProgressStore((s) => s.stage);

  return (
    <div>
      <h1>{stage}</h1>
      <button onClick={() => runJob(5)}>Start</button>
    </div>
  );
}


No subscriptions. No effects. No syncExternalStore. Nothing.

Why this is superior to hand-rolled stores

Your progressStore.js was basically:

subscribe

notify listeners

snapshot

Zustand already implements:

that

optimized subscriptions

React concurrency correctness

selector support

batching

devtools

middleware

persistence

And the key feature:

Can be updated from anywhere in the app, including non-React code

This is the exact use case Zustand advertises

From their docs:

‚ÄúZustand is ideal for situations where state must be accessed or updated outside React.‚Äù

Your problem is textbook Zustand.

Mental model shift

Instead of:

‚ÄúHow can I make React state accessible?‚Äù

Think:

‚ÄúI should not be using React state for this. I need app state, and React should read it.‚Äù

That‚Äôs what Zustand gives you.

When to use what
Situation	Tool
Pure UI state	useState
Async progress / external events / websockets / workers	Zustand
Server cache	React Query
Complex app domain state	Zustand / Redux
Result: Zero boilerplate, correct architecture

No more progressStore.js.
No more event emitters.
No more useSyncExternalStore.

Just:

useProgressStore.getState().setStage(...)


from literally anywhere.

That‚Äôs the intended solution.